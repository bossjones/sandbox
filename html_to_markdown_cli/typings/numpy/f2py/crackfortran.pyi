"""
This type stub file was generated by pyright.
"""

from .auxfuncs import *

"""
crackfortran --- read fortran (77,90) code and extract declaration information.

Copyright 1999-2004 Pearu Peterson all rights reserved,
Pearu Peterson <pearu@ioc.ee>
Permission to use, modify, and distribute this software is given under the
terms of the NumPy License.

NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
$Date: 2005/09/27 07:13:49 $
Pearu Peterson


Usage of crackfortran:
======================
Command line keys: -quiet,-verbose,-fix,-f77,-f90,-show,-h <pyffilename>
                   -m <module name for f77 routines>,--ignore-contains
Functions: crackfortran, crack2fortran
The following Fortran statements/constructions are supported
(or will be if needed):
   block data,byte,call,character,common,complex,contains,data,
   dimension,double complex,double precision,end,external,function,
   implicit,integer,intent,interface,intrinsic,
   logical,module,optional,parameter,private,public,
   program,real,(sequence?),subroutine,type,use,virtual,
   include,pythonmodule
Note: 'virtual' is mapped to 'dimension'.
Note: 'implicit integer (z) static (z)' is 'implicit static (z)' (this is minor bug).
Note: code after 'contains' will be ignored until its scope ends.
Note: 'common' statement is extended: dimensions are moved to variable definitions
Note: f2py directive: <commentchar>f2py<line> is read as <line>
Note: pythonmodule is introduced to represent Python module

Usage:
  `postlist=crackfortran(files)`
  `postlist` contains declaration information read from the list of files `files`.
  `crack2fortran(postlist)` returns a fortran code to be saved to pyf-file

  `postlist` has the following structure:
 *** it is a list of dictionaries containing `blocks':
     B = {'block','body','vars','parent_block'[,'name','prefix','args','result',
          'implicit','externals','interfaced','common','sortvars',
          'commonvars','note']}
     B['block'] = 'interface' | 'function' | 'subroutine' | 'module' |
                  'program' | 'block data' | 'type' | 'pythonmodule'
     B['body'] --- list containing `subblocks' with the same structure as `blocks'
     B['parent_block'] --- dictionary of a parent block:
                             C['body'][<index>]['parent_block'] is C
     B['vars'] --- dictionary of variable definitions
     B['sortvars'] --- dictionary of variable definitions sorted by dependence (independent first)
     B['name'] --- name of the block (not if B['block']=='interface')
     B['prefix'] --- prefix string (only if B['block']=='function')
     B['args'] --- list of argument names if B['block']== 'function' | 'subroutine'
     B['result'] --- name of the return value (only if B['block']=='function')
     B['implicit'] --- dictionary {'a':<variable definition>,'b':...} | None
     B['externals'] --- list of variables being external
     B['interfaced'] --- list of variables being external and defined
     B['common'] --- dictionary of common blocks (list of objects)
     B['commonvars'] --- list of variables used in common blocks (dimensions are moved to variable definitions)
     B['from'] --- string showing the 'parents' of the current block
     B['use'] --- dictionary of modules used in current block:
         {<modulename>:{['only':<0|1>],['map':{<local_name1>:<use_name1>,...}]}}
     B['note'] --- list of LaTeX comments on the block
     B['f2pyenhancements'] --- optional dictionary
          {'threadsafe':'','fortranname':<name>,
           'callstatement':<C-expr>|<multi-line block>,
           'callprotoargument':<C-expr-list>,
           'usercode':<multi-line block>|<list of multi-line blocks>,
           'pymethoddef:<multi-line block>'
           }
     B['entry'] --- dictionary {entryname:argslist,..}
     B['varnames'] --- list of variable names given in the order of reading the
                       Fortran code, useful for derived types.
     B['saved_interface'] --- a string of scanned routine signature, defines explicit interface
 *** Variable definition is a dictionary
     D = B['vars'][<variable name>] =
     {'typespec'[,'attrspec','kindselector','charselector','=','typename']}
     D['typespec'] = 'byte' | 'character' | 'complex' | 'double complex' |
                     'double precision' | 'integer' | 'logical' | 'real' | 'type'
     D['attrspec'] --- list of attributes (e.g. 'dimension(<arrayspec>)',
                       'external','intent(in|out|inout|hide|c|callback|cache|aligned4|aligned8|aligned16)',
                       'optional','required', etc)
     K = D['kindselector'] = {['*','kind']} (only if D['typespec'] =
                         'complex' | 'integer' | 'logical' | 'real' )
     C = D['charselector'] = {['*','len','kind']}
                             (only if D['typespec']=='character')
     D['='] --- initialization expression string
     D['typename'] --- name of the type if D['typespec']=='type'
     D['dimension'] --- list of dimension bounds
     D['intent'] --- list of intent specifications
     D['depend'] --- list of variable names on which current variable depends on
     D['check'] --- list of C-expressions; if C-expr returns zero, exception is raised
     D['note'] --- list of LaTeX comments on the variable
 *** Meaning of kind/char selectors (few examples):
     D['typespec>']*K['*']
     D['typespec'](kind=K['kind'])
     character*C['*']
     character(len=C['len'],kind=C['kind'])
     (see also fortran type declaration statement formats below)

Fortran 90 type declaration statement format (F77 is subset of F90)
====================================================================
(Main source: IBM XL Fortran 5.1 Language Reference Manual)
type declaration = <typespec> [[<attrspec>]::] <entitydecl>
<typespec> = byte                          |
             character[<charselector>]     |
             complex[<kindselector>]       |
             double complex                |
             double precision              |
             integer[<kindselector>]       |
             logical[<kindselector>]       |
             real[<kindselector>]          |
             type(<typename>)
<charselector> = * <charlen>               |
             ([len=]<len>[,[kind=]<kind>]) |
             (kind=<kind>[,len=<len>])
<kindselector> = * <intlen>                |
             ([kind=]<kind>)
<attrspec> = comma separated list of attributes.
             Only the following attributes are used in
             building up the interface:
                external
                (parameter --- affects '=' key)
                optional
                intent
             Other attributes are ignored.
<intentspec> = in | out | inout
<arrayspec> = comma separated list of dimension bounds.
<entitydecl> = <name> [[*<charlen>][(<arrayspec>)] | [(<arrayspec>)]*<charlen>]
                      [/<init_expr>/ | =<init_expr>] [,<entitydecl>]

In addition, the following attributes are used: check,depend,note

TODO:
    * Apply 'parameter' attribute (e.g. 'integer parameter :: i=2' 'real x(i)'
                                   -> 'real x(2)')
    The above may be solved by creating appropriate preprocessor program, for example.

"""
f2py_version = ...
strictf77 = ...
sourcecodeform = ...
quiet = ...
verbose = ...
tabchar = ...
pyffilename = ...
f77modulename = ...
skipemptyends = ...
ignorecontains = ...
dolowercase = ...
debug = ...
beginpattern = ...
currentfilename = ...
expectbegin = ...
f90modulevars = ...
filepositiontext = ...
gotnextfile = ...
groupcache = ...
groupcounter = ...
grouplist = ...
groupname = ...
include_paths = ...
neededmodule = ...
onlyfuncs = ...
previous_context = ...
skipblocksuntil = ...
skipfuncs = ...
skipfunctions = ...
usermodules = ...
def reset_global_f2py_vars(): # -> None:
    ...

def outmess(line, flag=...): # -> None:
    ...

defaultimplicitrules = ...
badnames = ...
invbadnames = ...
def rmbadname1(name):
    ...

def rmbadname(names): # -> list[Unknown]:
    ...

def undo_rmbadname1(name):
    ...

def undo_rmbadname(names): # -> list[Unknown]:
    ...

def getextension(name): # -> Literal['']:
    ...

is_f_file = ...
_has_f_header = ...
_has_f90_header = ...
_has_fix_header = ...
_free_f90_start = ...
def is_free_format(file): # -> Literal[1, 0]:
    """Check if file is in free format Fortran."""
    ...

def readfortrancode(ffile, dowithline=..., istop=...): # -> None:
    """
    Read fortran codes from files and
     1) Get rid of comments, line continuations, and empty lines; lower cases.
     2) Call dowithline(line) on every line.
     3) Recursively call itself when statement \"include '<filename>'\" is met.
    """
    ...

beforethisafter = ...
fortrantypes = ...
typespattern = ...
typespattern4implicit = ...
functionpattern = ...
subroutinepattern = ...
groupbegins77 = ...
beginpattern77 = ...
groupbegins90 = ...
beginpattern90 = ...
groupends = ...
endpattern = ...
endifs = ...
endifpattern = ...
implicitpattern = ...
dimensionpattern = ...
externalpattern = ...
optionalpattern = ...
requiredpattern = ...
publicpattern = ...
privatepattern = ...
intrinsicpattern = ...
intentpattern = ...
parameterpattern = ...
datapattern = ...
callpattern = ...
entrypattern = ...
callfunpattern = ...
commonpattern = ...
usepattern = ...
containspattern = ...
formatpattern = ...
f2pyenhancementspattern = ...
multilinepattern = ...
def split_by_unquoted(line, characters): # -> tuple[str | Any, str | Any] | tuple[Unknown, Literal['']]:
    """
    Splits the line into (line[:i], line[i:]),
    where i is the index of first occurrence of one of the characters
    not within quotes, or len(line) if no such index exists
    """
    ...

crackline_re_1 = ...
def crackline(line, reset=...): # -> None:
    """
    reset=-1  --- initialize
    reset=0   --- crack the line
    reset=1   --- final check if mismatch of blocks occurred

    Cracked data is saved in grouplist[0].
    """
    ...

def markouterparen(line): # -> str:
    ...

def markoutercomma(line, comma=...): # -> str | Any:
    ...

def unmarkouterparen(line):
    ...

def appenddecl(decl, decl2, force=...): # -> dict[Unknown, Unknown]:
    ...

selectpattern = ...
nameargspattern = ...
callnameargspattern = ...
real16pattern = ...
real8pattern = ...
_intentcallbackpattern = ...
def analyzeline(m, case, line): # -> None:
    ...

def appendmultiline(group, context_name, ml): # -> None:
    ...

def cracktypespec0(typespec, ll): # -> tuple[Unknown | Literal['double complex', 'double precision'], str | Any | None, str | Any | Unknown | None, str | Any | Unknown] | None:
    ...

namepattern = ...
kindselector = ...
charselector = ...
lenkindpattern = ...
lenarraypattern = ...
def removespaces(expr):
    ...

def markinnerspaces(line): # -> str:
    ...

def updatevars(typespec, selector, attrspec, entitydecl): # -> str | Any | None:
    ...

def cracktypespec(typespec, selector): # -> tuple[dict[str, str | Any] | None, dict[str, str | Any] | None, str | Any | None] | None:
    ...

def setattrspec(decl, attr, force=...): # -> dict[Unknown, Unknown]:
    ...

def setkindselector(decl, sel, force=...): # -> dict[Unknown, Unknown]:
    ...

def setcharselector(decl, sel, force=...): # -> dict[Unknown, Unknown]:
    ...

def getblockname(block, unknown=...):
    ...

def setmesstext(block): # -> None:
    ...

def get_usedict(block): # -> dict[Unknown, Unknown]:
    ...

def get_useparameters(block, param_map=...): # -> dict[Unknown, Unknown]:
    ...

def postcrack2(block, tab=..., param_map=...): # -> list[Unknown]:
    ...

def postcrack(block, args=..., tab=...): # -> list[Unknown] | dict[Unknown, Unknown]:
    """
    TODO:
          function return values
          determine expression types if in argument list
    """
    ...

def sortvarnames(vars): # -> list[Unknown]:
    ...

def analyzecommon(block):
    ...

def analyzebody(block, args, tab=...): # -> list[Unknown]:
    ...

def buildimplicitrules(block): # -> tuple[dict[Unknown, Unknown] | None, dict[Unknown, Unknown]]:
    ...

def myeval(e, g=..., l=...): # -> Any:
    ...

getlincoef_re_1 = ...
def getlincoef(e, xset): # -> tuple[Literal[0], int, None] | tuple[Literal[1], Literal[0], Unknown] | tuple[Any, Any, Unknown] | tuple[None, None, None]:
    ...

_varname_match = ...
def getarrlen(dl, args, star=...): # -> tuple[str, None, None] | tuple[str, Unknown | None, str] | tuple[str, Unknown | None, Any | str] | tuple[str, Unknown | None, Unknown] | tuple[str | Unknown, None, None]:
    ...

word_pattern = ...
def get_sorted_names(vars): # -> list[Unknown]:
    """
    """
    ...

def get_parameters(vars, global_params=...):
    ...

_is_kind_number = ...
def analyzevars(block):
    ...

analyzeargs_re_1 = ...
def expr2name(a, block, args=...): # -> str:
    ...

def analyzeargs(block):
    ...

determineexprtype_re_1 = ...
determineexprtype_re_2 = ...
determineexprtype_re_3 = ...
determineexprtype_re_4 = ...
determineexprtype_re_5 = ...
def determineexprtype(expr, vars, rules=...): # -> dict[str, str] | dict[Unknown, Unknown] | dict[str, str | dict[str, str]]:
    ...

def crack2fortrangen(block, tab=..., as_interface=...): # -> str:
    ...

def common2fortran(common, tab=...): # -> str:
    ...

def use2fortran(use, tab=...): # -> str:
    ...

def true_intent_list(var): # -> list[Unknown]:
    ...

def vars2fortran(block, vars, args, tab=..., as_interface=...): # -> str:
    """
    TODO:
    public sub
    ...
    """
    ...

def crackfortran(files):
    ...

def crack2fortran(block): # -> str:
    ...

if __name__ == "__main__":
    files = ...
    funcs = ...
    f = ...
    f2 = ...
    f3 = ...
    showblocklist = ...
    postlist = ...
