# supports flat-layout python project aka adhoc packaging
# INFO: https://setuptools.pypa.io/en/latest/userguide/package_discovery.html#flat-layout
[build-system]
build-backend = "setuptools.build_meta"
requires = ["build", "pytest-runner", "setuptools==66.1.1", "wheel"]
# backend-path = ["dancedetector"]

# SOURCE: https://packaging.python.org/en/latest/specifications/declaring-project-metadata/
[project]
authors = [{ name = "Prof Ex", email = "bossjones@theblacktonystark.com" }]
description = "Plugin for all universityofprofessorex interactions"
# maintainers = [{ name = "Prof Ex", email = "bossjones@theblacktonystark.com" }]
name = "dancedetector"
readme = "README.md"

classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Framework :: AsyncIO",
    "Intended Audience :: Developers",
    "Intended Audience :: End Users/Desktop",
    "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
    "Natural Language :: English",
    "Operating System :: MacOS :: MacOS X",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: POSIX :: Linux",
    "Programming Language :: Python :: 3 :: Only",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Topic :: Communications :: Chat",
]
# SOURCE: https://packaging.python.org/en/latest/specifications/declaring-project-metadata/
# Specifies which keys listed by this PEP were intentionally unspecified so another tool can/will provide such metadata dynamically. This clearly delineates which metadata is purposefully unspecified and expected to stay unspecified compared to being provided via tooling later on.

# A build back-end MUST honour statically-specified metadata (which means the metadata did not list the key in dynamic).

# A build back-end MUST raise an error if the metadata specifies name in dynamic.

# If the core metadata specification lists a field as "Required", then the metadata MUST specify the key statically or list it in dynamic (build back-ends MUST raise an error otherwise, i.e. it should not be possible for a required key to not be listed somehow in the [project] table).

# If the core metadata specification lists a field as "Optional", the metadata MAY list it in dynamic if the expectation is a build back-end will provide the data for the key later.

# Build back-ends MUST raise an error if the metadata specifies a key statically as well as being listed in dynamic.

# If the metadata does not list a key in dynamic, then a build back-end CANNOT fill in the requisite metadata on behalf of the user (i.e. dynamic is the only way to allow a tool to fill in metadata and the user must opt into the filling in).

# Build back-ends MUST raise an error if the metadata specifies a key in dynamic but the build back-end was unable to determine the data for it (omitting the data, if determined to be the accurate value, is acceptable).

# NOTE: setuptools equivalents: version, python_requires, install_requires, extra_require
# dynamic = ["version", "requires-python", "dependencies", "optional-dependencies"]
# dynamic = ["version", "dependencies", "optional-dependencies"]
dependencies = [
    "joblib",
    "aiorwlock",
    "aiohttp",
    "aiofile",
    "aiorwlock",
    "autoflake==1.4",
    "autopep8==1.6.0",
    "bandit",
    "better_exceptions",
    "black",
    "bpython",
    # "codecov==2.1.12",
    "tensorflow-macos",
    "debugpy",
    "docutils==0.16",
    "fer==22.4.0",
    "ffpyplayer==4.3.5",
    "flake8==4.0.1",
    "freezegun",
    "hunter",
    "invoke",
    "isort",
    "lazy-object-proxy",
    "logging_tree",
    "loguru",
    "lxml",
    "matplotlib",
    "mccabe>=0.6.0,<0.7.0",
    "mediapipe==0.9.3.0",
    "MonkeyType",
    "mss==6.1.0",
    "mypy",
    "numpy",
    "pathlib_mate",
    "pdbpp",
    "pip-tools",
    "pre-commit",
    "pycodestyle==2.8.0",
    "pydantic[email,dotenv]",
    "pyflakes==2.4.0",
    "pygments",
    "pyinspect",
    "pylint==2.14.2",
    "pytablewriter[html]",
    "pytest-black==0.3.12",
    "pytest-clarity==1.0.1",
    "pytest-cov==4.0.0",
    "pytest-dotenv==0.5.2",
    "pytest-env==0.6.2",
    "pytest-flake8==1.1.1",
    "pytest-leaks==0.3.1",
    "pytest-mock==3.7.0",
    "pytest-mypy==0.9.1",
    "pytest-rerunfailures",
    "pytest-sugar==0.9.4",
    "pytest-timeout==2.1.0",
    "pytest-watch==4.2.0",
    "pytest==7.2.0",
    "python-dotenv>=0.19.2",
    "python-Levenshtein",
    "python-slugify",
    "pytz==2023.2",
    "redis==4.5.1",
    "requests",
    "restructuredtext_lint",
    "rich",
    "rope==1.1.1",
    "ruff",
    "scenedetect[opencv]",
    "scipy",
    "sourcery",
    "tenacity",
    "tensorboard==2.12.0",
    "tomli==1.2.2",
    "tqdm",
    "typer",
    "types-colorama",
    "types-dataclasses",
    "types-freezegun",
    "types-mock",
    "types-pytz",
    "types-PyYAML",
    "types-requests",
    "types-setuptools",
    "types-six",
    "typing-extensions>=4.3,<5",
    "uritemplate",
    "uritools",
    "validate-pyproject[all]",
    "vulture",
    "webcolors",
    "websockets",
]
dynamic = ["license", "version"]

    [project.optional-dependencies]
    dev = [
        "MonkeyType",

    ]

    tests = [
        "flake8==4.0.1",

    ]

    docs = [
        "docutils==0.16",
        ]


    [project.urls]
    changelog = "https://github.com/me/spam/blob/master/CHANGELOG.md"
    documentation = "https://readthedocs.org"
    homepage = "https://dancedetector.org"
    repository = "https://github.com/dancedetector/dancedetector"


    [project.scripts]
    dancedetectorctl = "dancedetector.cli:CLI"
    # dancedetectorctl-setup = "redbot.bootstrap:run_cli"

    # SOURCE: https://www.wheelodex.org/entry-points/pytest11/
    # SOURCE: https://docs.pytest.org/en/7.1.x/how-to/writing_plugins.html
    # INFO: pytest11 entry points are used by pytest to register pytest plugins. If a project defines a pytest11 entry point that points to a module containing one or more pytest hook functions, then once the project is installed, pytest will automatically load the plugin module and execute its hooks. See the pytest documentation for more information.
    [project.entry-points.pytest11]
    dancedetector = "dancedetector.pytest"

[tool.pyright]
exclude = ["**/__pycache__", "**/node_modules", "tasks", "typings"]
include = ["dancedetector"]
# ignore = ["src/oldstuff"]
# defineConstant [map of constants to values (boolean or string), optional]: Set of identifiers that should be assumed to contain a constant value wherever used within this program. For example, { "DEBUG": true } indicates that pyright should assume that the identifier DEBUG will always be equal to True. If this identifier is used within a conditional expression (such as if not DEBUG:) pyright will use the indicated value to determine whether the guarded block is reachable or not. Member expressions that reference one of these constants (e.g. my_module.DEBUG) are also supported.
# defineConstant = { DEBUG = true }
# stubPath = "typings"
# venv = "env367"

# https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportUndefinedVariable
reportInvalidTypeVarUse = "warning"
reportMissingImports = true
reportMissingTypeStubs = false
reportUndefinedVariable = "error"

# reportUninitializedInstanceVariable [boolean or string, optional]: Generate or suppress diagnostics for instance variables within a class that are not initialized or declared within the class body or the __init__ method. The default value for this setting is "none".

# reportInvalidStringEscapeSequence [boolean or string, optional]: Generate or suppress diagnostics for invalid escape sequences used within string literals. The Python specification indicates that such sequences will generate a syntax error in future versions. The default value for this setting is "warning".

# reportUnknownParameterType [boolean or string, optional]: Generate or suppress diagnostics for input or return parameters for functions or methods that have an unknown type. The default value for this setting is "none".

# reportUnknownArgumentType [boolean or string, optional]: Generate or suppress diagnostics for call arguments for functions or methods that have an unknown type. The default value for this setting is "none".

# reportUnknownLambdaType [boolean or string, optional]: Generate or suppress diagnostics for input or return parameters for lambdas that have an unknown type. The default value for this setting is "none".

# reportUnknownVariableType [boolean or string, optional]: Generate or suppress diagnostics for variables that have an unknown type. The default value for this setting is "none".

# reportUnknownMemberType [boolean or string, optional]: Generate or suppress diagnostics for class or instance variables that have an unknown type. The default value for this setting is "none".

# reportMissingParameterType [boolean or string, optional]: Generate or suppress diagnostics for input parameters for functions or methods that are missing a type annotation. Th

pythonVersion = "3.9"

[tool.isort]
# https://github.com/PyCQA/isort/wiki/isort-Settings
multi_line_output = 3
profile = "black"
# src_paths = ["dancedetector",]
group_by_package = true

# SOURCE: https://github.com/home-assistant/core/blob/dev/pyproject.toml
# will group `import x` and `from x import` of the same module.
combine_as_imports = true
force_sort_within_sections = true
forced_separate = ["tests"]
known_first_party = [
    "dancedetector",
    # "tests",
]
known_third_party = ["fastapi", "pydantic", "starlette", "torch", "torchvision"]
# SOURCE: https://github.com/home-assistant/core/blob/dev/pyproject.toml - end
extend_skip_glob = ["*/db/migration/*", "*/site-packages/*"]


[tool.mypy]
allow_subclassing_any = true
allow_untyped_calls = true
allow_untyped_decorators = true
exclude = ["./contrib/"]
ignore_missing_imports = true
implicit_reexport = true
namespace_packages = true
pretty = true
show_error_codes = true
strict = true
warn_return_any = false
warn_unused_ignores = false

    # # Remove this and add `types-redis`
    # # when the issue https://github.com/python/typeshed/issues/8242 is resolved.
    # [[tool.mypy.overrides]]
    # ignore_missing_imports = true
    # module = ['redis.asyncio']

[tool.ruff]
ignore-init-module-imports = true
line-length = 120
target-version = "py310"
ignore = [
    "B008", # do not perform function calls in argument defaults
    "C901", # too complex
    "E501", # line too long, handled by black
    "ANN102",  # Missing type annotation for `cls` in classmethod
    "ANN206",  # Missing return type annotation for classmethod `__subclasshook__`
    "ANN401",  # Dynamically typed expressions (typing.Any) are disallowed in `func`
    "PLR0912", # Too many branches
    "TRY400",  # Use logging.exception instead of logging.error
    "PTH123",  # open("foo") should be replaced by Path("foo").open()
    "D415", # pydocstyle First line should end with a period, question mark, or exclamation point
    # "D101" # Missing docstring in public class
]
select = [
    "E", # pycodestyle errors
    "F", # pyflakes
    "W", # pycodestyle warnings
    "I",  # isort
    "B", # flake8-bugbear
    "C", # flake8-comprehensions
    # "D" # pydocstyle

    # SOURCE: https://github.com/WorkHardes/python-useful/blob/ed206221192b0e02276630ed9b2837ba3ff8f152/linters/ruff/pyproject.toml
    # "N",   # pep8-naming
    # "UP",  # pyupgrade
    # "YTT", # flake8-2020
    # "ANN", # flake8-annotations
    # "FBT", # flake8-boolean-trap
    # "S",   # flake8-bandit
    # "A",   # flake8-builtins
    # "C4",  # flake8-comprehensions
    # "T10", # flake8-debugger
    # "EM",  # flake8-errmsg
    # "EXE", # flake8-executable
    # "ISC", # flake8-implicit-str-concat
    # "ICN", # flake8-import-conventions
    # "PIE", # flake8-pie
    # "T20", # flake8-print
    # "PYI", # flake8-pyi
    # "PT",  # flake8-pytest-style
    # "Q",   # flake8-quotes
    # "RSE", # flake8-raise
    # "SLF", # flake8-self
    # "SIM", # flake8-simplify
    # "TID", # flake8-tidy-imports
    # "ARG", # flake8-unused-arguments
    # "PTH", # flake8-use-pathlib
    # "PGH", # pygrep-hooks
    # "PLC", # pylint convention
    # "PLE", # pylint error
    # "PLR", # pylint refactor
    # "PLW", # pylint warning
    # "TRY", # tryceratops
    # "RUF", # Ruff-specific rules
]

# ------------------------------------
# NOTE: Ruff rule keys
# ------------------------------------
# Pyflakes (F)
# pycodestyle (E, W)
# Error (E)
# Warning (W)
# mccabe (C90)
# isort (I)
# pep8-naming (N)
# pydocstyle (D)
# pyupgrade (UP)
# flake8-2020 (YTT)
# flake8-annotations (ANN)
# flake8-bandit (S)
# flake8-blind-except (BLE)
# flake8-boolean-trap (FBT)
# flake8-bugbear (B)
# flake8-builtins (A)
# flake8-commas (COM)
# flake8-comprehensions (C4)
# flake8-datetimez (DTZ)
# flake8-debugger (T10)
# flake8-django (DJ)
# flake8-errmsg (EM)
# flake8-executable (EXE)
# flake8-implicit-str-concat (ISC)
# flake8-import-conventions (ICN)
# flake8-logging-format (G)
# flake8-no-pep420 (INP)
# flake8-pie (PIE)
# flake8-print (T20)
# flake8-pyi (PYI)
# flake8-pytest-style (PT)
# flake8-quotes (Q)
# flake8-raise (RSE)
# flake8-return (RET)
# flake8-self (SLF)
# flake8-simplify (SIM)
# flake8-tidy-imports (TID)
# flake8-type-checking (TCH)
# flake8-unused-arguments (ARG)
# flake8-use-pathlib (PTH)
# eradicate (ERA)
# pandas-vet (PD)
# pygrep-hooks (PGH)
# Pylint (PL)
# Convention (PLC)
# Error (PLE)
# Refactor (PLR)
# Warning (PLW)
# tryceratops (TRY)
# NumPy-specific rules (NPY)
# Ruff-specific rules (RUF)

# Allow autofix for all enabled rules (when `--fix`) is provided.
fixable = [
"A", # flake8-builtins (A)
"B", # flake8-bugbear (B)
"C", # mccabe, flake8-commas, lake8-comprehensions (C4)
"D", # pydocstyle (D)
"E", # pycodestyle
"F", # pyflakes
"I001" # Import block is un-sorted or un-formatte
]
unfixable = [
"ERA", # eradicate (ERA)
"S" # bandit
]

# Exclude a variety of commonly ignored directories.
exclude = [
    "__pypackages__",
    "_build",
    ".bzr",
    ".direnv",
    ".eggs",
    ".git",
    ".hg",
    ".mypy_cache",
    ".nox",
    ".pants.d",
    ".ruff_cache",
    ".svn",
    ".tox",
    ".venv",
    "buck-out",
    "build",
    "dist",
    "node_modules",
    "venv",
]

# Whether to enforce exclude and extend-exclude patterns, even for paths that are passed to Ruff explicitly. Typically, Ruff will lint any paths passed in directly, even if they would typically be excluded. Setting force-exclude = true will cause Ruff to respect these exclusions unequivocally.
force-exclude = true

# Allow unused variables when underscore-prefixed.
dummy-variable-rgx = "^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$"

    [tool.ruff.per-file-ignores]
    "__init__.py" = ["F401"]
    "dancedetector/cli.py" = ["E402"]
    "dancedetector/bot.py" = ["E402"]

    # https://beta.ruff.rs/docs/settings/#force-wrap-aliases
    [tool.ruff.isort]
    force-sort-within-sections = true
    combine-as-imports = true
    force-wrap-aliases = true
    order-by-type = true
    known-first-party = ["dancedetector", "tests"]
    known-third-party = [
        "fastapi",
        "pydantic",
        "starlette",
        "torch",
        "torchvision",
    ]

[tool.commitizen]
bump_message = "bump: version $current_version → $new_version"
name = "dancedetector"
tag_format = "$version"
update_changelog_on_bump = true
version = "1.0.0"
version_files = [
    "dancedetector/__init__.py:__version__",
    "pyproject.toml:version",
]

# SOURCE: https://setuptools.pypa.io/en/latest/userguide/package_discovery.html
# flat-layout
# (also known as "adhoc")

# The package folder(s) are placed directly under the project root:

# project_root_directory
# ├── pyproject.toml  # AND/OR setup.cfg, setup.py
# ├── ...
# └── mypkg/
#     ├── __init__.py
#     ├── ...
#     ├── module.py
#     ├── subpkg1/
#     │   ├── __init__.py
#     │   ├── ...
#     │   └── module1.py
#     └── subpkg2/
#         ├── __init__.py
#         ├── ...
#         └── module2.py

# # If the automatic discovery does not work for you (e.g., you want to include in the distribution top-level packages with reserved names such as tasks, example or docs, or you want to exclude nested packages that would be otherwise included), you can use the provided tools for package discovery:
# # SOURCE: https://setuptools.pypa.io/en/latest/userguide/package_discovery.html
# [tool.setuptools.packages]
# find = {} # Scanning implicit namespaces is active by default

# package-dir = { "dancedetector" = "dancedetector" }
# packages = ["dancedetector"]

[tool.setuptools.packages.find]
"where" = ["."]
# # needed only because we did not adopt src layout yet
# include = ["dancedetector*"]

# [tool.distutils.sdist]
# formats = "gztar"

# [tool.distutils.wheel]
# universal = true

# [tool.distutils.bdist_wheel]
# universal = true

[tool.setuptools.dynamic.version]
attr = "dancedetector.__init__.__version__"

# [tool.setuptools]
# package-dir = {"" = "src"}
# zip-safe = true
# platforms = ["any"]
# [tool.setuptools.packages.find]
# where = ["src"]

###################################################
# invokeai
###################################################

# [tool.setuptools.dynamic]
# version = { attr = "ldm.invoke.__version__" }

# [tool.setuptools.packages.find]
# "where" = ["."]
# "include" = ["invokeai.assets.web*", "invokeai.backend*", "invokeai.frontend.dist*", "invokeai.configs*", "ldm*"]

# [tool.setuptools.package-data]
# "invokeai.assets.web" = ["**.png"]
# "invokeai.backend" = ["**.png"]
# "invokeai.configs" = ["*.example", "**/*.yaml", "*.txt"]
# "invokeai.frontend.dist" = ["**"]

# [tool.pytest.ini_options]
# addopts = "-p pytest_cov --junitxml=junit/test-results.xml --cov-report=term:skip-covered --cov=ldm/invoke --cov=backend --cov-branch"
[tool.black]
line-length = 120
target-version = ['py310']
exclude = '''
/(
    \.git
  | \.mypy_cache
  | \.ruff_cache
  | \.venv
  | scripts
)/
'''

[tool.autoflake]
# Return messages from pyflakes.
check = true

[tool.ruff.pydocstyle]
convention = "google"

[tool.vulture]
# exclude = ["**/__pycache__", "**/node_modules", "tasks", "typings", ".git/*"]
exclude = ["*/__pypackages__",
    "*/_build",
    "*/.bzr",
    "*/.direnv",
    "*/.eggs",
    "*/.git",
    "*/.hg",
    "*/.mypy_cache",
    "*/.nox",
    "*/.pants.d",
    "*/.ruff_cache",
    "*/.svn",
    "*/.tox",
    "*/.venv",
    "*/buck-out",
    "*/build",
    "*/dist",
    "*/node_modules",
    "*/venv"]

ignore_decorators = ["@app.route", "@require_*"]
ignore_names = ["visit_*", "do_*", "exc_type", "exc_val", "exc_tb", "excinfo"]
# The recommended option is to add used code that is reported as unused to a Python module and add it to the list of scanned paths. To obtain such a whitelist automatically, pass --make-whitelist to Vulture:
make_whitelist = true
# You can use the --min-confidence flag to set the minimum confidence for code to be reported as unused. Use --min-confidence 100 to only report code that is guaranteed to be unused within the analyzed files.
min_confidence = 90
paths = ["myscript.py", "mydir"]
# When using the --sort-by-size option, Vulture sorts unused code by its number of lines. This helps developers prioritize where to look for dead code first.
sort_by_size = true
# verbose = true
